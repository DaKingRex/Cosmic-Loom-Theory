"""
Bioelectric Field Simulator for Cosmic Loom Theory

Simulates bioelectric fields as a primary mechanism for establishing
spatial coherence across biological systems.

From CLT v1.1 Section 4.1:
Bioelectric fields are endogenous electric fields generated by ionic gradients
across cell membranes. They play a direct causal role in large-scale biological
organization - during development, regeneration, and repair.

Key concepts:
- Membrane potential (Vm): Voltage across cell membrane (~-70mV at rest)
- Ion channels: Na+, K+ channels control ionic conductance
- Gap junctions: Allow direct current flow between neighboring cells
- Bioelectric patterns: Stable voltage distributions that encode spatial information

This simulator demonstrates how local ionic changes propagate through
gap junction networks to create and maintain coherent bioelectric patterns.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button, RadioButtons
from matplotlib.colors import LinearSegmentedColormap
from matplotlib.patches import Circle
from typing import Tuple, List, Optional, Dict, Callable
from dataclasses import dataclass, field
from enum import Enum
import matplotlib.animation as animation


# =============================================================================
# PHYSICAL CONSTANTS AND PARAMETERS
# =============================================================================

# Membrane potential values (in mV)
V_REST = -70.0      # Resting membrane potential
V_THRESHOLD = -55.0  # Action potential threshold
V_DEPOLARIZED = -20.0  # Typical depolarized state
V_HYPERPOLARIZED = -90.0  # Hyperpolarized state
V_REVERSAL_NA = 60.0   # Sodium reversal potential
V_REVERSAL_K = -90.0   # Potassium reversal potential

# Conductance values (in mS/cm²)
G_NA_MAX = 120.0    # Max sodium conductance
G_K_MAX = 36.0      # Max potassium conductance
G_LEAK = 0.3        # Leak conductance
G_GAP_DEFAULT = 1.0  # Default gap junction conductance

# Time constants (in ms)
TAU_NA = 1.0        # Sodium channel time constant
TAU_K = 4.0         # Potassium channel time constant

# Capacitance
C_M = 1.0           # Membrane capacitance (µF/cm²)


class IonChannelState(Enum):
    """States for ion channels."""
    CLOSED = 0
    OPEN = 1
    INACTIVATED = 2


@dataclass
class CellState:
    """State of a single cell in the bioelectric network."""
    Vm: float = V_REST                    # Membrane potential (mV)
    n_Na: float = 0.0                     # Sodium channel activation (0-1)
    n_K: float = 0.0                      # Potassium channel activation (0-1)
    g_gap: np.ndarray = field(default_factory=lambda: np.ones(4) * G_GAP_DEFAULT)
    # Gap junction conductances: [up, down, left, right]


class BioelectricSimulator:
    """
    2D tissue simulation of bioelectric field dynamics.

    Models a grid of cells with:
    - Individual membrane potentials
    - Voltage-gated ion channels (Na+, K+)
    - Gap junction connections to neighbors
    - Bioelectric pattern formation and maintenance

    The simulation uses a simplified Hodgkin-Huxley-like model
    adapted for epithelial/non-excitable cells, focusing on
    steady-state bioelectric patterns rather than action potentials.
    """

    def __init__(self,
                 grid_size: Tuple[int, int] = (50, 50),
                 dx: float = 10.0,  # Cell spacing in µm
                 dt: float = 0.1):  # Time step in ms
        """
        Initialize the bioelectric simulator.

        Args:
            grid_size: (rows, cols) number of cells
            dx: Spatial step size (µm)
            dt: Time step (ms)
        """
        self.rows, self.cols = grid_size
        self.dx = dx
        self.dt = dt
        self.time = 0.0

        # Primary state: membrane potential for each cell
        self.Vm = np.ones((self.rows, self.cols)) * V_REST

        # Ion channel states (gating variables)
        self.n_Na = np.zeros((self.rows, self.cols))  # Na+ activation
        self.h_Na = np.ones((self.rows, self.cols))   # Na+ inactivation
        self.n_K = np.zeros((self.rows, self.cols))   # K+ activation

        # Gap junction conductances (4 directions per cell)
        # Shape: (rows, cols, 4) for [up, down, left, right]
        self.g_gap = np.ones((self.rows, self.cols, 4)) * G_GAP_DEFAULT

        # External current injection (can be used for stimulation)
        self.I_ext = np.zeros((self.rows, self.cols))

        # Ion channel densities (can vary across tissue)
        self.g_Na_density = np.ones((self.rows, self.cols)) * G_NA_MAX
        self.g_K_density = np.ones((self.rows, self.cols)) * G_K_MAX
        self.g_leak = np.ones((self.rows, self.cols)) * G_LEAK

        # History tracking
        self.history: List[np.ndarray] = []
        self.coherence_history: List[float] = []

    def reset(self):
        """Reset all cells to resting state."""
        self.Vm = np.ones((self.rows, self.cols)) * V_REST
        self.n_Na = np.zeros((self.rows, self.cols))
        self.h_Na = np.ones((self.rows, self.cols))
        self.n_K = np.zeros((self.rows, self.cols))
        self.I_ext = np.zeros((self.rows, self.cols))
        self.time = 0.0
        self.history = []
        self.coherence_history = []

    # =========================================================================
    # ION CHANNEL DYNAMICS
    # =========================================================================

    def _alpha_n_Na(self, V: np.ndarray) -> np.ndarray:
        """Sodium activation rate constant."""
        # Sigmoid activation centered around threshold
        return 0.1 * (V - V_THRESHOLD + 10) / (1 - np.exp(-(V - V_THRESHOLD + 10) / 10) + 1e-10)

    def _beta_n_Na(self, V: np.ndarray) -> np.ndarray:
        """Sodium deactivation rate constant."""
        return 4.0 * np.exp(-(V - V_REST) / 18)

    def _alpha_h_Na(self, V: np.ndarray) -> np.ndarray:
        """Sodium inactivation rate constant."""
        return 0.07 * np.exp(-(V - V_REST) / 20)

    def _beta_h_Na(self, V: np.ndarray) -> np.ndarray:
        """Sodium de-inactivation rate constant."""
        return 1.0 / (1 + np.exp(-(V - V_THRESHOLD + 10) / 10) + 1e-10)

    def _alpha_n_K(self, V: np.ndarray) -> np.ndarray:
        """Potassium activation rate constant."""
        return 0.01 * (V - V_REST + 10) / (1 - np.exp(-(V - V_REST + 10) / 10) + 1e-10)

    def _beta_n_K(self, V: np.ndarray) -> np.ndarray:
        """Potassium deactivation rate constant."""
        return 0.125 * np.exp(-(V - V_REST) / 80)

    def _steady_state_n_Na(self, V: np.ndarray) -> np.ndarray:
        """Steady-state sodium activation."""
        alpha = self._alpha_n_Na(V)
        beta = self._beta_n_Na(V)
        return alpha / (alpha + beta + 1e-10)

    def _steady_state_n_K(self, V: np.ndarray) -> np.ndarray:
        """Steady-state potassium activation."""
        alpha = self._alpha_n_K(V)
        beta = self._beta_n_K(V)
        return alpha / (alpha + beta + 1e-10)

    def _update_ion_channels(self):
        """Update ion channel gating variables."""
        # Sodium activation
        alpha_n = self._alpha_n_Na(self.Vm)
        beta_n = self._beta_n_Na(self.Vm)
        tau_n = 1.0 / (alpha_n + beta_n + 1e-10)
        n_inf = alpha_n * tau_n
        self.n_Na += self.dt * (n_inf - self.n_Na) / (tau_n + 1e-10)
        self.n_Na = np.clip(self.n_Na, 0, 1)

        # Sodium inactivation
        alpha_h = self._alpha_h_Na(self.Vm)
        beta_h = self._beta_h_Na(self.Vm)
        tau_h = 1.0 / (alpha_h + beta_h + 1e-10)
        h_inf = alpha_h * tau_h
        self.h_Na += self.dt * (h_inf - self.h_Na) / (tau_h + 1e-10)
        self.h_Na = np.clip(self.h_Na, 0, 1)

        # Potassium activation
        alpha_k = self._alpha_n_K(self.Vm)
        beta_k = self._beta_n_K(self.Vm)
        tau_k = 1.0 / (alpha_k + beta_k + 1e-10)
        k_inf = alpha_k * tau_k
        self.n_K += self.dt * (k_inf - self.n_K) / (tau_k + 1e-10)
        self.n_K = np.clip(self.n_K, 0, 1)

    # =========================================================================
    # MEMBRANE CURRENTS
    # =========================================================================

    def _compute_ionic_currents(self) -> np.ndarray:
        """Compute total ionic currents for each cell."""
        # Sodium current: I_Na = g_Na * m³h * (V - E_Na)
        # Using simplified m = n_Na for this model
        I_Na = self.g_Na_density * (self.n_Na ** 3) * self.h_Na * (self.Vm - V_REVERSAL_NA)

        # Potassium current: I_K = g_K * n⁴ * (V - E_K)
        I_K = self.g_K_density * (self.n_K ** 4) * (self.Vm - V_REVERSAL_K)

        # Leak current: I_leak = g_leak * (V - V_rest)
        I_leak = self.g_leak * (self.Vm - V_REST)

        return I_Na + I_K + I_leak

    def _compute_gap_junction_currents(self) -> np.ndarray:
        """
        Compute currents flowing through gap junctions.

        Gap junction current between cells i and j:
        I_gap = g_gap * (V_j - V_i)
        """
        I_gap = np.zeros_like(self.Vm)

        # Current from cell above (if exists)
        # g_gap[:,:,0] is conductance to cell above
        I_gap[1:, :] += self.g_gap[1:, :, 0] * (self.Vm[:-1, :] - self.Vm[1:, :])

        # Current from cell below
        I_gap[:-1, :] += self.g_gap[:-1, :, 1] * (self.Vm[1:, :] - self.Vm[:-1, :])

        # Current from cell to the left
        I_gap[:, 1:] += self.g_gap[:, 1:, 2] * (self.Vm[:, :-1] - self.Vm[:, 1:])

        # Current from cell to the right
        I_gap[:, :-1] += self.g_gap[:, :-1, 3] * (self.Vm[:, 1:] - self.Vm[:, :-1])

        return I_gap

    # =========================================================================
    # SIMULATION STEPPING
    # =========================================================================

    def step(self, n_steps: int = 1):
        """
        Advance the simulation by n_steps time steps.

        Uses forward Euler integration of the membrane equation:
        C_m * dV/dt = -I_ionic + I_gap + I_ext
        """
        for _ in range(n_steps):
            # Update ion channel states
            self._update_ion_channels()

            # Compute currents
            I_ionic = self._compute_ionic_currents()
            I_gap = self._compute_gap_junction_currents()

            # Membrane potential update: dV/dt = (-I_ionic + I_gap + I_ext) / C_m
            dVdt = (-I_ionic + I_gap + self.I_ext) / C_M
            self.Vm += self.dt * dVdt

            # Clamp to physiological range
            self.Vm = np.clip(self.Vm, -120.0, 60.0)

            self.time += self.dt

    def run(self, duration: float, record_interval: float = 1.0):
        """
        Run simulation for specified duration.

        Args:
            duration: Total simulation time (ms)
            record_interval: How often to record state (ms)
        """
        n_steps = int(duration / self.dt)
        record_steps = int(record_interval / self.dt)

        for i in range(n_steps):
            self.step(1)

            if i % record_steps == 0:
                self.history.append(self.Vm.copy())
                self.coherence_history.append(self.compute_spatial_coherence())

    # =========================================================================
    # STIMULATION AND MANIPULATION
    # =========================================================================

    def depolarize_region(self, center: Tuple[int, int], radius: int,
                          target_Vm: float = V_DEPOLARIZED):
        """
        Depolarize a circular region of cells.

        Args:
            center: (row, col) center of region
            radius: Radius in cells
            target_Vm: Target membrane potential (mV)
        """
        r0, c0 = center
        for r in range(max(0, r0 - radius), min(self.rows, r0 + radius + 1)):
            for c in range(max(0, c0 - radius), min(self.cols, c0 + radius + 1)):
                if (r - r0)**2 + (c - c0)**2 <= radius**2:
                    self.Vm[r, c] = target_Vm

    def hyperpolarize_region(self, center: Tuple[int, int], radius: int,
                             target_Vm: float = V_HYPERPOLARIZED):
        """Hyperpolarize a circular region of cells."""
        self.depolarize_region(center, radius, target_Vm)

    def set_external_current(self, center: Tuple[int, int], radius: int,
                             current: float):
        """
        Apply external current to a region.

        Args:
            center: (row, col) center of region
            radius: Radius in cells
            current: Current amplitude (µA/cm²)
        """
        r0, c0 = center
        for r in range(max(0, r0 - radius), min(self.rows, r0 + radius + 1)):
            for c in range(max(0, c0 - radius), min(self.cols, c0 + radius + 1)):
                if (r - r0)**2 + (c - c0)**2 <= radius**2:
                    self.I_ext[r, c] = current

    def create_injury(self, center: Tuple[int, int], radius: int):
        """
        Create an "injury" by breaking gap junctions in a region.

        This simulates tissue damage where cells become electrically isolated.
        """
        r0, c0 = center
        for r in range(max(0, r0 - radius), min(self.rows, r0 + radius + 1)):
            for c in range(max(0, c0 - radius), min(self.cols, c0 + radius + 1)):
                if (r - r0)**2 + (c - c0)**2 <= radius**2:
                    # Set all gap junction conductances to zero
                    self.g_gap[r, c, :] = 0.0

                    # Also disable connections from neighbors
                    if r > 0:
                        self.g_gap[r-1, c, 1] = 0.0  # Neighbor's down connection
                    if r < self.rows - 1:
                        self.g_gap[r+1, c, 0] = 0.0  # Neighbor's up connection
                    if c > 0:
                        self.g_gap[r, c-1, 3] = 0.0  # Neighbor's right connection
                    if c < self.cols - 1:
                        self.g_gap[r, c+1, 2] = 0.0  # Neighbor's left connection

    def heal_injury(self, center: Tuple[int, int], radius: int,
                    heal_rate: float = 0.5):
        """
        Partially restore gap junctions in an injured region.

        Args:
            center: (row, col) center of region
            radius: Radius in cells
            heal_rate: Fraction of normal conductance to restore (0-1)
        """
        r0, c0 = center
        g_healed = G_GAP_DEFAULT * heal_rate

        for r in range(max(0, r0 - radius), min(self.rows, r0 + radius + 1)):
            for c in range(max(0, c0 - radius), min(self.cols, c0 + radius + 1)):
                if (r - r0)**2 + (c - c0)**2 <= radius**2:
                    self.g_gap[r, c, :] = g_healed

                    # Also restore neighbor connections
                    if r > 0:
                        self.g_gap[r-1, c, 1] = g_healed
                    if r < self.rows - 1:
                        self.g_gap[r+1, c, 0] = g_healed
                    if c > 0:
                        self.g_gap[r, c-1, 3] = g_healed
                    if c < self.cols - 1:
                        self.g_gap[r, c+1, 2] = g_healed

    def set_gap_junction_strength(self, conductance: float):
        """Set uniform gap junction conductance across all cells."""
        self.g_gap[:, :, :] = conductance

    # =========================================================================
    # CLT COHERENCE METRICS
    # =========================================================================

    def compute_spatial_coherence(self) -> float:
        """
        Compute spatial coherence of the bioelectric field.

        Higher coherence = more uniform/coordinated membrane potentials.
        This measures how "together" the tissue is acting.

        Returns:
            Coherence value between 0 (chaotic) and 1 (perfectly uniform)
        """
        if self.Vm.size == 0:
            return 0.0

        # Normalized standard deviation (inverse measure of uniformity)
        Vm_normalized = (self.Vm - V_HYPERPOLARIZED) / (V_REVERSAL_NA - V_HYPERPOLARIZED)
        std = np.std(Vm_normalized)
        mean = np.mean(Vm_normalized)

        # Coefficient of variation (lower = more coherent)
        if abs(mean) < 1e-10:
            cv = std
        else:
            cv = std / abs(mean)

        # Convert to coherence metric (0-1 scale)
        coherence = np.exp(-cv * 2)  # Exponential mapping

        return float(coherence)

    def compute_gradient_coherence(self) -> float:
        """
        Compute coherence based on spatial gradients.

        Smooth gradients indicate organized patterns.
        High local variation indicates incoherence.
        """
        # Compute spatial gradients
        grad_r = np.diff(self.Vm, axis=0)
        grad_c = np.diff(self.Vm, axis=1)

        # Gradient magnitude
        grad_mag_r = np.mean(np.abs(grad_r))
        grad_mag_c = np.mean(np.abs(grad_c))
        avg_gradient = (grad_mag_r + grad_mag_c) / 2

        # Normalize by voltage range
        V_range = V_REVERSAL_NA - V_HYPERPOLARIZED
        normalized_gradient = avg_gradient / V_range

        # Lower gradient = higher coherence
        coherence = np.exp(-normalized_gradient * 10)

        return float(coherence)

    def compute_pattern_energy(self) -> float:
        """
        Compute the "pattern energy" - deviation from resting state.

        This represents the energetic cost of maintaining a bioelectric pattern.
        """
        deviation = self.Vm - V_REST
        energy = np.mean(deviation ** 2)
        return float(energy)

    def compute_gap_junction_connectivity(self) -> float:
        """
        Compute average gap junction connectivity.

        Returns fraction of maximum possible connectivity.
        """
        return float(np.mean(self.g_gap) / G_GAP_DEFAULT)

    def map_to_er_space(self) -> Dict[str, float]:
        """
        Map current bioelectric state to CLT éR phase space.

        Energy Present (EP): Related to pattern energy and metabolic activity
        Frequency (f): Related to dynamics/fluctuation rate

        Returns:
            Dict with 'ep', 'freq', and 'er' values
        """
        # EP: Based on pattern energy (deviation from rest) + connectivity
        pattern_energy = self.compute_pattern_energy()
        connectivity = self.compute_gap_junction_connectivity()

        # Scale pattern energy to EP range (1-10)
        # Higher deviation = more energy required to maintain
        ep = 1.5 + pattern_energy / 500.0 * 5.0  # Rough scaling
        ep = np.clip(ep, 0.5, 10.0)

        # Frequency: Based on inverse of coherence (more chaotic = higher freq)
        coherence = self.compute_spatial_coherence()
        # High coherence = low frequency (stable), low coherence = high freq (chaotic)
        freq = 0.5 + (1 - coherence) * 3.5
        freq = np.clip(freq, 0.3, 4.5)

        # Modulate by connectivity (isolated cells have higher effective frequency)
        freq *= (2 - connectivity)

        # Compute éR
        er = ep / (freq ** 2)

        return {
            'energy_present': float(ep),
            'frequency': float(freq),
            'energy_resistance': float(er),
            'coherence': float(coherence),
            'connectivity': float(connectivity),
            'pattern_energy': float(pattern_energy)
        }


# =============================================================================
# PRESETS: COMMON BIOELECTRIC CONFIGURATIONS
# =============================================================================

def create_uniform_preset(grid_size: Tuple[int, int] = (50, 50)) -> BioelectricSimulator:
    """Create simulator with uniform resting potential."""
    sim = BioelectricSimulator(grid_size=grid_size)
    return sim


def create_depolarized_region_preset(grid_size: Tuple[int, int] = (50, 50)) -> BioelectricSimulator:
    """Create simulator with a central depolarized region."""
    sim = BioelectricSimulator(grid_size=grid_size)
    center = (grid_size[0] // 2, grid_size[1] // 2)
    sim.depolarize_region(center, radius=8, target_Vm=-30.0)
    return sim


def create_bioelectric_pattern_preset(grid_size: Tuple[int, int] = (50, 50)) -> BioelectricSimulator:
    """
    Create simulator with a stable bioelectric pattern.

    Mimics the type of patterns seen in planarian regeneration
    or embryonic development - multiple distinct voltage domains.
    """
    sim = BioelectricSimulator(grid_size=grid_size)

    rows, cols = grid_size

    # Create a pattern: left half depolarized, right half at rest
    # with a gradient transition zone
    for c in range(cols):
        # Sigmoid transition
        x = (c - cols / 2) / (cols / 8)
        Vm = V_REST + (V_DEPOLARIZED - V_REST) / (1 + np.exp(x))
        sim.Vm[:, c] = Vm

    return sim


def create_injured_tissue_preset(grid_size: Tuple[int, int] = (50, 50)) -> BioelectricSimulator:
    """Create simulator with an injured region (broken gap junctions)."""
    sim = BioelectricSimulator(grid_size=grid_size)
    center = (grid_size[0] // 2, grid_size[1] // 2)

    # Create injury
    sim.create_injury(center, radius=6)

    # Injured region often depolarizes due to ion imbalance
    sim.depolarize_region(center, radius=6, target_Vm=-40.0)

    return sim


def create_regeneration_preset(grid_size: Tuple[int, int] = (50, 50)) -> BioelectricSimulator:
    """
    Create preset showing regeneration-like bioelectric dynamics.

    Based on observations that successful regeneration involves
    re-establishment of coherent bioelectric patterns.
    """
    sim = BioelectricSimulator(grid_size=grid_size)
    center = (grid_size[0] // 2, grid_size[1] // 2)

    # Create initial injury
    sim.create_injury(center, radius=6)
    sim.depolarize_region(center, radius=6, target_Vm=-40.0)

    # Begin partial healing
    sim.heal_injury(center, radius=6, heal_rate=0.3)

    return sim


# =============================================================================
# VISUALIZER
# =============================================================================

class BioelectricVisualizer:
    """
    Interactive visualizer for bioelectric field dynamics.

    Provides real-time visualization with:
    - Color-coded membrane potential display
    - Gap junction connectivity overlay
    - CLT coherence metrics panel
    - Interactive controls for stimulation
    """

    # Custom colormap: hyperpolarized (blue) -> rest (green) -> depolarized (yellow/red)
    COLORMAP_COLORS = [
        (0.1, 0.1, 0.5),    # Deep blue - hyperpolarized
        (0.2, 0.4, 0.8),    # Blue - below rest
        (0.2, 0.7, 0.3),    # Green - resting
        (0.9, 0.8, 0.2),    # Yellow - slightly depolarized
        (0.9, 0.3, 0.1),    # Red-orange - depolarized
    ]

    def __init__(self, simulator: BioelectricSimulator):
        """
        Initialize the visualizer.

        Args:
            simulator: BioelectricSimulator instance to visualize
        """
        self.sim = simulator
        self.fig = None
        self.ax_main = None
        self.ax_coherence = None
        self.ax_er = None
        self.im = None
        self.cbar = None

        # Create custom colormap
        self.cmap = LinearSegmentedColormap.from_list(
            'membrane_potential',
            self.COLORMAP_COLORS,
            N=256
        )

        # Animation state
        self.anim = None
        self.running = False

        # Interaction state
        self.click_mode = 'depolarize'  # or 'hyperpolarize', 'injure'

    def setup_plot(self, figsize: Tuple[int, int] = (16, 10)):
        """Set up the matplotlib figure and axes."""
        self.fig = plt.figure(figsize=figsize, facecolor='#1a1a2e')

        # Main membrane potential display
        self.ax_main = self.fig.add_axes([0.05, 0.25, 0.55, 0.65])
        self.ax_main.set_facecolor('#16213e')

        # Coherence time series
        self.ax_coherence = self.fig.add_axes([0.65, 0.55, 0.30, 0.35])
        self.ax_coherence.set_facecolor('#16213e')

        # éR phase space position
        self.ax_er = self.fig.add_axes([0.65, 0.10, 0.30, 0.35])
        self.ax_er.set_facecolor('#16213e')

        # Style axes
        for ax in [self.ax_main, self.ax_coherence, self.ax_er]:
            for spine in ax.spines.values():
                spine.set_color('#4a5568')
            ax.tick_params(colors='#a0aec0')

    def _draw_membrane_potential(self):
        """Draw the membrane potential field."""
        # Normalize Vm for colormap
        Vm_normalized = (self.sim.Vm - V_HYPERPOLARIZED) / (V_REVERSAL_NA - V_HYPERPOLARIZED)
        Vm_normalized = np.clip(Vm_normalized, 0, 1)

        if self.im is None:
            self.im = self.ax_main.imshow(
                Vm_normalized,
                cmap=self.cmap,
                aspect='equal',
                origin='lower',
                vmin=0, vmax=1,
                interpolation='bilinear'
            )

            # Colorbar
            self.cbar = self.fig.colorbar(self.im, ax=self.ax_main, fraction=0.046, pad=0.04)
            self.cbar.set_label('Membrane Potential', color='#a0aec0', fontsize=10)
            self.cbar.ax.yaxis.set_tick_params(color='#a0aec0')
            plt.setp(plt.getp(self.cbar.ax.axes, 'yticklabels'), color='#a0aec0')

            # Custom ticks showing mV values
            self.cbar.set_ticks([0, 0.25, 0.47, 0.75, 1.0])
            self.cbar.set_ticklabels(['-90mV', '-70mV', '-55mV', '-20mV', '+60mV'])
        else:
            self.im.set_data(Vm_normalized)

        self.ax_main.set_xlabel('Cell Column', color='#e2e8f0', fontsize=11)
        self.ax_main.set_ylabel('Cell Row', color='#e2e8f0', fontsize=11)
        self.ax_main.set_title(
            f'Bioelectric Field (t = {self.sim.time:.1f} ms)\n'
            f'Coherence: {self.sim.compute_spatial_coherence():.3f}',
            color='#f7fafc', fontsize=14, fontweight='bold'
        )

    def _draw_coherence_plot(self):
        """Draw the coherence time series."""
        self.ax_coherence.clear()
        self.ax_coherence.set_facecolor('#16213e')

        if len(self.sim.coherence_history) > 1:
            t = np.arange(len(self.sim.coherence_history))
            self.ax_coherence.plot(t, self.sim.coherence_history, '-',
                                   color='#00ff88', linewidth=2)
            self.ax_coherence.fill_between(t, self.sim.coherence_history,
                                           alpha=0.3, color='#00ff88')

        self.ax_coherence.set_xlim(0, max(len(self.sim.coherence_history), 100))
        self.ax_coherence.set_ylim(0, 1)
        self.ax_coherence.set_xlabel('Time Steps', color='#e2e8f0', fontsize=10)
        self.ax_coherence.set_ylabel('Spatial Coherence', color='#e2e8f0', fontsize=10)
        self.ax_coherence.set_title('Coherence Over Time', color='#f7fafc', fontsize=12)

        for spine in self.ax_coherence.spines.values():
            spine.set_color('#4a5568')
        self.ax_coherence.tick_params(colors='#a0aec0')

    def _draw_er_space(self):
        """Draw current position in éR phase space."""
        self.ax_er.clear()
        self.ax_er.set_facecolor('#16213e')

        # Get current éR mapping
        er_state = self.sim.map_to_er_space()
        ep = er_state['energy_present']
        freq = er_state['frequency']
        er = er_state['energy_resistance']

        # Draw viable window boundaries
        ep_range = np.linspace(0.5, 10, 100)
        er_min, er_max = 0.5, 5.0  # CLT viable window

        # f = sqrt(EP / éR)
        f_lower = np.sqrt(ep_range / er_max)
        f_upper = np.sqrt(ep_range / er_min)

        self.ax_er.fill_between(ep_range, f_lower, f_upper,
                                alpha=0.2, color='#00ff88', label='Viable Window')
        self.ax_er.plot(ep_range, f_lower, '--', color='#00ff88', linewidth=1.5)
        self.ax_er.plot(ep_range, f_upper, '--', color='#00ff88', linewidth=1.5)

        # Plot current state
        self.ax_er.scatter([ep], [freq], s=200, c='#ffd700', marker='*',
                          edgecolors='white', linewidths=2, zorder=10,
                          label=f'Current (éR={er:.2f})')

        # Zone labels
        self.ax_er.text(2, 4.2, 'CHAOS', fontsize=10, color='#9f7aea',
                       ha='center', fontweight='bold', alpha=0.7)
        self.ax_er.text(8, 0.8, 'RIGIDITY', fontsize=10, color='#4299e1',
                       ha='center', fontweight='bold', alpha=0.7)

        self.ax_er.set_xlim(0.5, 10)
        self.ax_er.set_ylim(0.3, 4.5)
        self.ax_er.set_xlabel('Energy Present (EP)', color='#e2e8f0', fontsize=10)
        self.ax_er.set_ylabel('Frequency (f)', color='#e2e8f0', fontsize=10)
        self.ax_er.set_title('Position in éR Phase Space', color='#f7fafc', fontsize=12)
        self.ax_er.legend(loc='upper right', fontsize=8,
                         facecolor='#2d3748', edgecolor='#4a5568',
                         labelcolor='#e2e8f0')

        for spine in self.ax_er.spines.values():
            spine.set_color('#4a5568')
        self.ax_er.tick_params(colors='#a0aec0')

    def _setup_controls(self):
        """Set up interactive controls."""
        # Control buttons
        ax_depol = self.fig.add_axes([0.05, 0.10, 0.10, 0.04])
        ax_hypol = self.fig.add_axes([0.16, 0.10, 0.10, 0.04])
        ax_injure = self.fig.add_axes([0.27, 0.10, 0.10, 0.04])
        ax_heal = self.fig.add_axes([0.38, 0.10, 0.10, 0.04])
        ax_reset = self.fig.add_axes([0.49, 0.10, 0.10, 0.04])

        self.btn_depol = Button(ax_depol, 'Depolarize', color='#fc8181', hovercolor='#f56565')
        self.btn_hypol = Button(ax_hypol, 'Hyperpolarize', color='#4299e1', hovercolor='#3182ce')
        self.btn_injure = Button(ax_injure, 'Injure', color='#f6ad55', hovercolor='#ed8936')
        self.btn_heal = Button(ax_heal, 'Heal', color='#68d391', hovercolor='#48bb78')
        self.btn_reset = Button(ax_reset, 'Reset', color='#a0aec0', hovercolor='#718096')

        # Gap junction slider
        ax_gap = self.fig.add_axes([0.05, 0.04, 0.35, 0.025])
        self.slider_gap = Slider(ax_gap, 'Gap Junction', 0.0, 3.0,
                                valinit=G_GAP_DEFAULT, valstep=0.1, color='#9f7aea')
        ax_gap.set_facecolor('#2d3748')

        # Mode radio buttons
        ax_mode = self.fig.add_axes([0.45, 0.01, 0.15, 0.08])
        ax_mode.set_facecolor('#2d3748')
        self.radio_mode = RadioButtons(ax_mode,
                                       ('Depolarize', 'Hyperpolarize', 'Injure'),
                                       active=0)
        for label in self.radio_mode.labels:
            label.set_color('#e2e8f0')
            label.set_fontsize(9)

        # Connect callbacks
        self.btn_depol.on_clicked(self._on_depolarize_click)
        self.btn_hypol.on_clicked(self._on_hyperpolarize_click)
        self.btn_injure.on_clicked(self._on_injure_click)
        self.btn_heal.on_clicked(self._on_heal_click)
        self.btn_reset.on_clicked(self._on_reset_click)
        self.slider_gap.on_changed(self._on_gap_change)
        self.radio_mode.on_clicked(self._on_mode_change)

        # Connect mouse click on main plot
        self.fig.canvas.mpl_connect('button_press_event', self._on_click)

    def _on_depolarize_click(self, event):
        """Depolarize center of tissue."""
        center = (self.sim.rows // 2, self.sim.cols // 2)
        self.sim.depolarize_region(center, radius=5)
        self._update_display()

    def _on_hyperpolarize_click(self, event):
        """Hyperpolarize center of tissue."""
        center = (self.sim.rows // 2, self.sim.cols // 2)
        self.sim.hyperpolarize_region(center, radius=5)
        self._update_display()

    def _on_injure_click(self, event):
        """Create injury at center."""
        center = (self.sim.rows // 2, self.sim.cols // 2)
        self.sim.create_injury(center, radius=5)
        self._update_display()

    def _on_heal_click(self, event):
        """Heal injury at center."""
        center = (self.sim.rows // 2, self.sim.cols // 2)
        self.sim.heal_injury(center, radius=5, heal_rate=0.8)
        self._update_display()

    def _on_reset_click(self, event):
        """Reset simulation."""
        self.sim.reset()
        self._update_display()

    def _on_gap_change(self, val):
        """Update gap junction conductance."""
        self.sim.set_gap_junction_strength(val)

    def _on_mode_change(self, label):
        """Change click mode."""
        self.click_mode = label.lower()

    def _on_click(self, event):
        """Handle clicks on the main plot."""
        if event.inaxes != self.ax_main:
            return

        # Get cell coordinates from click
        col = int(event.xdata)
        row = int(event.ydata)

        if 0 <= row < self.sim.rows and 0 <= col < self.sim.cols:
            if self.click_mode == 'depolarize':
                self.sim.depolarize_region((row, col), radius=3)
            elif self.click_mode == 'hyperpolarize':
                self.sim.hyperpolarize_region((row, col), radius=3)
            elif self.click_mode == 'injure':
                self.sim.create_injury((row, col), radius=3)

            self._update_display()

    def _update_display(self):
        """Update all display elements."""
        self._draw_membrane_potential()
        self._draw_coherence_plot()
        self._draw_er_space()
        self.fig.canvas.draw_idle()

    def _animate(self, frame):
        """Animation callback."""
        # Run simulation steps
        self.sim.step(10)

        # Record coherence
        self.sim.coherence_history.append(self.sim.compute_spatial_coherence())

        # Update display
        self._draw_membrane_potential()
        self._draw_coherence_plot()
        self._draw_er_space()

        return [self.im]

    def run_animation(self, interval: int = 50):
        """
        Start animated simulation.

        Args:
            interval: Milliseconds between frames
        """
        self.anim = animation.FuncAnimation(
            self.fig, self._animate,
            interval=interval, blit=False
        )
        self.running = True

    def render(self, animate: bool = True, save_path: Optional[str] = None):
        """
        Render the visualization.

        Args:
            animate: Whether to run animation
            save_path: If provided, save static figure to this path
        """
        self.setup_plot()
        self._draw_membrane_potential()
        self._draw_coherence_plot()
        self._draw_er_space()
        self._setup_controls()

        # Add info text
        info_text = (
            "BIOELECTRIC FIELD SIMULATOR\n"
            "━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
            "Click on tissue to apply\n"
            "selected stimulation mode.\n\n"
            "Gap junctions enable\n"
            "electrical coupling between\n"
            "cells, allowing coherent\n"
            "bioelectric patterns.\n\n"
            "Injury breaks connections,\n"
            "disrupting coherence.\n"
            "Healing restores coupling."
        )
        self.fig.text(0.62, 0.02, info_text, fontsize=8,
                     color='#a0aec0', family='monospace',
                     verticalalignment='bottom')

        if animate:
            self.run_animation()

        if save_path:
            self.fig.savefig(save_path, dpi=150, facecolor=self.fig.get_facecolor(),
                            bbox_inches='tight', pad_inches=0.3)
            print(f"Figure saved to: {save_path}")

        plt.show()


# =============================================================================
# DEMO FUNCTIONS
# =============================================================================

def demo():
    """Run a demonstration of the bioelectric field simulator."""
    print("=" * 70)
    print("  Cosmic Loom Theory: Bioelectric Field Simulator")
    print("  Phase 2.1 - Biological Substrate Models")
    print("=" * 70)
    print("\nBioelectric fields are a primary mechanism for establishing")
    print("spatial coherence across biological systems (CLT v1.1 §4.1).")
    print("\nKey concepts:")
    print("  • Membrane potential: Voltage across cell membrane (~-70mV at rest)")
    print("  • Gap junctions: Allow direct electrical coupling between cells")
    print("  • Bioelectric patterns: Stable voltage distributions encoding spatial info")
    print("\nInteractive controls:")
    print("  • Click tissue to apply stimulation (depolarize/hyperpolarize/injure)")
    print("  • Adjust gap junction conductance with slider")
    print("  • Watch coherence evolve in real-time")
    print("  • See current state mapped to CLT éR phase space")
    print("=" * 70)

    # Create simulator with uniform preset
    sim = create_uniform_preset(grid_size=(50, 50))

    # Create and run visualizer
    viz = BioelectricVisualizer(sim)
    viz.render(animate=True)


def demo_pattern_formation():
    """Demonstrate bioelectric pattern formation and maintenance."""
    print("=" * 70)
    print("  Bioelectric Pattern Formation Demo")
    print("=" * 70)
    print("\nShowing a pre-formed bioelectric pattern similar to those")
    print("observed during development and regeneration.")
    print("\nWatch how the pattern stabilizes and maintains itself")
    print("through gap junction coupling.")
    print("=" * 70)

    sim = create_bioelectric_pattern_preset(grid_size=(50, 50))
    viz = BioelectricVisualizer(sim)
    viz.render(animate=True)


def demo_injury_regeneration():
    """Demonstrate injury and regeneration dynamics."""
    print("=" * 70)
    print("  Injury & Regeneration Demo")
    print("=" * 70)
    print("\nSimulating tissue injury (broken gap junctions) and")
    print("subsequent regeneration (re-coupling).")
    print("\nNote how:")
    print("  • Injury disrupts spatial coherence")
    print("  • Injured region becomes electrically isolated")
    print("  • Healing restores gap junctions and coherence")
    print("  • Pattern information can be restored")
    print("=" * 70)

    sim = create_injured_tissue_preset(grid_size=(50, 50))
    viz = BioelectricVisualizer(sim)
    viz.render(animate=True)


if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        if sys.argv[1] == '--pattern':
            demo_pattern_formation()
        elif sys.argv[1] == '--injury':
            demo_injury_regeneration()
        else:
            demo()
    else:
        demo()
